#!/usr/bin/env bash
set -euo pipefail

show_help() {
  cat <<'EOF'
bcodex: run codex inside a bubblewrap sandbox.

Usage:
  bcodex [--help] [--print-cmd] [--] [codex args...]

Options:
  --help       Show this help.
  --print-cmd  Print the effective bwrap command and exit.
  --           End wrapper options; remaining args go to codex.

Behavior:
  - Mounts / read-only.
  - Mounts current working directory writable.
  - Mounts $HOME/.codex writable.
  - Mounts /tmp/bcodex/<session_id> writable.
  - Masks common sensitive paths (for example $HOME/.ssh).
  - Sets BWRAP_CODEX=1 and BCODEX_* environment markers.
  - Runs codex with --yolo.
EOF
}

need_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    echo "error: required command not found: $1" >&2
    exit 127
  fi
}

check_bwrap_runtime() {
  local tmp_err
  tmp_err="$(mktemp)"
  if bwrap --ro-bind / / --proc /proc --dev /dev -- /bin/true 2>"${tmp_err}"; then
    rm -f "${tmp_err}"
    return 0
  fi

  if grep -q "setting up uid map: Permission denied" "${tmp_err}"; then
    cat >&2 <<'EOF'
error: bubblewrap cannot create a user namespace on this host.
reason: "setting up uid map: Permission denied"

This usually means unprivileged user namespaces are restricted (often by AppArmor).

Fix options:
  1) Enable unprivileged user namespaces:
     sudo sysctl -w kernel.apparmor_restrict_unprivileged_userns=0
  2) Or use a setuid-enabled bubblewrap binary (distro-dependent packaging).

After applying one option, rerun bcodex.
EOF
    rm -f "${tmp_err}"
    exit 126
  fi

  echo "error: bubblewrap preflight failed:" >&2
  sed 's/^/  /' "${tmp_err}" >&2 || true
  rm -f "${tmp_err}"
  exit 126
}

PRINT_CMD=0
while [[ $# -gt 0 ]]; do
  case "$1" in
    --help)
      show_help
      exit 0
      ;;
    --print-cmd)
      PRINT_CMD=1
      shift
      ;;
    --)
      shift
      break
      ;;
    *)
      break
      ;;
  esac
done

need_cmd bwrap
if [[ "${PRINT_CMD}" -eq 0 ]]; then
  need_cmd codex
  check_bwrap_runtime
fi

PWD_ABS="$(pwd)"
HOME_ABS="${HOME:?HOME is not set}"
CODEX_HOME="${HOME_ABS}/.codex"
SESSION_ID="${BCODEX_SESSION_ID:-$(date +%Y%m%d-%H%M%S)-$$}"
TMPDIR_HOST="/tmp/bcodex/${SESSION_ID}"
TMPDIR_INNER="/tmp/bcodex/${SESSION_ID}"

mkdir -p "${CODEX_HOME}"
mkdir -p "${TMPDIR_HOST}"
mkdir -p "${PWD_ABS}/.bcodex/cache"
mkdir -p "${PWD_ABS}/.bcodex/state"
mkdir -p "${PWD_ABS}/.bcodex/runtime"

XDG_CACHE_INNER="${PWD_ABS}/.bcodex/cache"
XDG_STATE_INNER="${PWD_ABS}/.bcodex/state"
XDG_RUNTIME_INNER="${PWD_ABS}/.bcodex/runtime"

user_has_yolo=0
for arg in "$@"; do
  if [[ "${arg}" == "--yolo" ]]; then
    user_has_yolo=1
    break
  fi
done

codex_cmd=(codex)
if [[ "${user_has_yolo}" -eq 0 ]]; then
  codex_cmd+=(--yolo)
fi
codex_cmd+=("$@")

bwrap_args=(
  --die-with-parent
  --new-session
  --ro-bind / /
  --bind "${PWD_ABS}" "${PWD_ABS}"
  --bind "${CODEX_HOME}" "${CODEX_HOME}"
  --proc /proc
  --dev /dev
  --tmpfs /tmp
  --dir /tmp/bcodex
  --bind "${TMPDIR_HOST}" "${TMPDIR_INNER}"
  --chdir "${PWD_ABS}"
  --setenv HOME "${HOME_ABS}"
  --setenv BWRAP_CODEX 1
  --setenv BCODEX_SESSION_ID "${SESSION_ID}"
  --setenv BCODEX_TMPDIR "${TMPDIR_INNER}"
  --setenv TMPDIR "${TMPDIR_INNER}"
  --setenv XDG_CACHE_HOME "${XDG_CACHE_INNER}"
  --setenv XDG_STATE_HOME "${XDG_STATE_INNER}"
  --setenv XDG_RUNTIME_DIR "${XDG_RUNTIME_INNER}"
)

mask_paths=(
  "${HOME_ABS}/.ssh"
  "${HOME_ABS}/.gnupg"
  "${HOME_ABS}/.aws"
  "${HOME_ABS}/.kube"
  "${HOME_ABS}/.config/gcloud"
  "${HOME_ABS}/.netrc"
  "${HOME_ABS}/.pypirc"
  "${HOME_ABS}/.npmrc"
  "${HOME_ABS}/.docker/config.json"
)

for p in "${mask_paths[@]}"; do
  if [[ "${p}" == "${CODEX_HOME}" ]]; then
    continue
  fi
  if [[ ! -e "${p}" ]]; then
    continue
  fi
  if [[ -d "${p}" ]]; then
    bwrap_args+=(--tmpfs "${p}")
  else
    bwrap_args+=(--ro-bind /dev/null "${p}")
  fi
done

if [[ "${PRINT_CMD}" -eq 1 ]]; then
  printf '%q ' bwrap "${bwrap_args[@]}" -- "${codex_cmd[@]}"
  printf '\n'
  exit 0
fi

exec bwrap "${bwrap_args[@]}" -- "${codex_cmd[@]}"
